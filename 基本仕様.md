# Jun専用パーソナルAIエージェントBot 実装仕様書

1. 全体構成図とディレクトリ構成案

Figure: Discord DM経由でユーザー(Jun)が送信したメッセージを、自宅サーバー上のBotが受信して処理するアーキテクチャ構成図。BotはOpenAIのLLM API（ChatGPT）を呼び出し、応答や各種機能(ToDo管理・リマインダー等)を実行する。また、BotはローカルのSQLiteデータベースに対してToDoやリマインダー情報を保存・更新する。最後に、生成された応答や通知をDiscordのDMでユーザーに送信する。

上記の図に示すように、本システムはDiscordのDM上で動作するBotとして構築されます。ユーザー(Jun)がDiscordのダイレクトメッセージでBotにメッセージを送信すると、DiscordのAPIを通じて自宅サーバー上のBotアプリケーションがそのメッセージを受け取ります。Botアプリケーションはメッセージ内容に応じて、OpenAIのChatGPT API（GPT-3.5もしくはGPT-4）に問い合わせを行い、必要に応じて内部機能の呼び出し（ToDo追加やリマインド設定など）を実行します ￼。Bot内部ではSQLiteデータベースを使用してToDoリストやリマインダー、スケジュール情報を永続化し管理します。処理結果（LLMからの回答やリマインド通知メッセージなど）は、再びDiscord APIを経由してユーザーのDMに返信されます。
このように、Discord (フロントエンド) ⇔ Botサーバー(Python) ⇔ OpenAI API/ローカルDB という非同期通信の流れでシステムが構成されています。

ディレクトリ構成は、モジュール分離と保守性を高めるため機能ごとに整理します ￼。以下は提案するプロジェクトディレクトリ構成案です：

jun_personal_ai_bot/            ← プロジェクトルートディレクトリ
├── README.md                   ← 説明書や起動方法などのドキュメント
├── requirements.txt            ← 使用ライブラリとバージョン (pip用)
├── config.yaml                 ← アプリケーション設定ファイル（静的設定）
├── .env                        ← 環境変数定義（機密情報、Git管理外）
├── main.py                     ← エントリポイント: Bot起動スクリプト
├── bot/                        ← ソースコードパッケージ
│   ├── __init__.py
│   ├── discord_client.py       ← Discord Botの初期化・イベント処理
│   ├── llm_client.py           ← OpenAI LLM APIとの連携処理
│   ├── todo_service.py         ← ToDo管理機能のモジュール
│   ├── reminder_service.py     ← リマインダー機能のモジュール
│   ├── schedule_service.py     ← スケジュール管理機能のモジュール
│   └── data_store.py           ← データベース操作モジュール(SQLite接続など)
└── systemd/junbot.service      ← (任意) systemd用のサービス定義ファイル

メインスクリプト(main.py)では設定ファイルや環境変数を読み込み、Discord Botクライアントを起動します。bot/ディレクトリ以下に、各機能毎のモジュール（サービスクラス）と、外部API連携やDB処理を行うモジュールを配置しています。例えばtodo_service.pyにはToDo管理のロジック、reminder_service.pyにはリマインダー設定・通知ロジックを実装します。モジュールをこのように分離することで、機能追加や改修時にも影響範囲が限定され保守しやすくなります ￼。

2. 使用ライブラリとインストール要件（requirements.txt）

このBotシステムの実装にはPythonの以下の主要なライブラリを使用します。それぞれのライブラリの役割も併記します。
	•	discord.py (Python Discord APIラッパー) ￼
DiscordのBotを開発するための公式APIラッパーライブラリです。Botのログイン、メッセージ受信、DM送信などDiscordとの通信全般を担います。
インストール: discord.py (バージョン2.2.0以上推奨)
	•	OpenAI Pythonライブラリ
OpenAI社のChatGPT APIを呼び出すための公式ライブラリです。ユーザーからの質問への回答生成や、自然言語によるコマンド解析のために、GPT-3.5/4モデルへのリクエスト送信に使用します。
インストール: openai (最新バージョン推奨、関数呼び出し機能利用のため>=0.27.0)
	•	python-dotenv (環境変数ロード) ￼
.envファイルに定義した環境変数をPython実行時に読み込むためのライブラリです。DiscordトークンやOpenAI APIキーのような機密情報をソースコードから分離し、環境変数として安全に管理する目的で使用します ￼。
インストール: python-dotenv
	•	PyYAML (YAMLファイルパーサ)
設定ファイルconfig.yamlを読み込むために使用します。Botの各種設定値（使用するモデル種別やユーザーIDなど）をYAML形式で管理し、起動時に読み込みます。
インストール: PyYAML
	•	SQLite3 (組み込み)
Python標準ライブラリとして組み込まれている軽量データベースです。追加のインストールは不要です。本Botではローカル永続データの保存にSQLiteを利用します。Python組み込みのsqlite3モジュール経由で操作します。

必要に応じて以下のライブラリも検討します：
	•	dateutil 等の日時処理ライブラリ (任意) – ユーザーの入力する日時表現のパースやタイムゾーン処理に利用できますが、ChatGPTを介して解析させる場合は必須ではありません。
	•	aiohttp – Discord.py内部で依存として使用されます（discord.pyインストール時に自動で入ります）。
	•	APScheduler や discord.ext.tasks – リマインダー通知の定期実行に使用できます。discord.pyのtasksループ機能で代替可能なため、本仕様では追加ライブラリは使わずに実装予定です。

requirements.txtには上記ライブラリを以下のように記載します（バージョンは執筆時の最新安定版の例）:

discord.py>=2.2.0
openai>=0.27.0
python-dotenv>=1.0.0
PyYAML>=6.0

この他、開発環境で必要に応じてテスト用のライブラリや型チェックツール（pytestやmypy等）を使用しても良いでしょう。ただし、本Bot本体の動作に必須ではないため省略しています。

3. モジュール一覧（役割・入出力）

設計上、各機能は独立したモジュール（Pythonファイル）およびクラスとして実装します。これによりコードの見通しが良くなり、機能の追加・削除も容易になります ￼。主なモジュールとその役割、入出力インタフェースは以下の通りです。
	•	main.py (エントリポイント)
アプリケーションの起動スクリプトです。環境変数・設定ファイルの読み込み、Discordクライアントの初期化、各機能モジュール（Cog）の登録を行います。discord.Clientもしくはcommands.Botをインスタンス化し、Botのイベントハンドラ(on_message 等)やコマンドを設定します。また、Botの実行開始 (bot.run(token)) もここで行います。
入力: なし（実行時に環境変数・設定を読み込む）
出力: なし（Discord接続を開始し、プロセスを常駐させる）
	•	discord_client.py (Discordボットクライアント)
Discord APIとの接続処理とイベントハンドリングを担当します。discord.pyのcommands.Bot（もしくはdiscord.Client）を継承したクラスを定義し、on_messageイベントでDMを受信した際の処理を実装します。受信メッセージをLLMに渡し、得られた回答や機能実行結果をctx.send()やdm_channel.send()で返信します。実質的には他のサービスクラスを呼び出すコントローラ的な役割です。
入力: Discordからのイベント（メッセージ内容、送信者ID等）
出力: ユーザーへのDiscordメッセージ送信（返信やエラーメッセージ）
	•	llm_client.py (LLM連携モジュール)
OpenAIのChatGPT APIを呼び出す機能をカプセル化したモジュールです。ChatCompletionエンドポイントへのリクエスト組み立て（システムメッセージや関数定義の設定）と、APIレスポンスの解析を行います。ここでChatGPTからの回答やfunction_callを受け取り、必要に応じて後述する各サービス（ToDo管理など）の関数を呼び出します。
入力: ユーザーからのメッセージ内容、コンテキスト（会話履歴やシステムプロンプト）
出力: ChatGPTの回答（テキスト）、または呼び出すべき関数名と引数
	•	todo_service.py (ToDo管理サービス)
ユーザーのToDoリストを管理するビジネスロジックを実装します。タスクの追加・完了・削除・一覧表示などのメソッドを提供し、内部でデータベース（tasksテーブル）へのアクセスを行います。Discordのコマンドでいうと「todo追加」「todo一覧」「todo完了」等に対応する機能です。
入力: タスク内容（文字列）、（必要なら期限日時）等
出力: 処理結果（成功/失敗）やタスク一覧データ
	•	reminder_service.py (リマインダーサービス)
ユーザーからの「○○を日時にリマインドして」という要求を処理します。新規リマインダーの登録、既存リマインダー一覧の取得、リマインダー取り消し等の機能を提供します。時間になった際にDiscord上でユーザーにDM通知する機能も含みます。内部的にはremindersテーブルへのデータ保存と、定期的な時間チェックループ（後述）が動きます。
入力: リマインド内容（テキスト）、リマインド時刻(DateTime)
出力: 処理結果（リマインダーID等）やリマインド通知そのもの（Discordメッセージ）
	•	schedule_service.py (スケジュール管理サービス)
ユーザー個人の予定を簡易管理する機能です。日付と内容を指定して予定を登録し、予定一覧を取得したりできます（シンプルなカレンダー的機能）。必要最小限の実装として、日時とイベント名称を記録し、予定一覧を照会する程度に留めます。将来的に外部カレンダーとの連携等も視野に入れてモジュール分離してあります。
入力: イベント名称、日時情報
出力: 処理結果（イベントID等）やスケジュール一覧データ
	•	data_store.py (データ永続化モジュール)
SQLiteを操作し、データの保存・読み出しを行うユーティリティを提供します。アプリ起動時にデータベースファイル（例: data.sqlite）に接続し、必要ならテーブルを作成します。各サービスからこのモジュールを呼び出し、SQLクエリ実行やトランザクション管理を行います。シンプルな構成では、このモジュール内にadd_task(query), get_tasks(), add_reminder(...)等の関数を実装しておき、サービス側から利用する形でも構いません。モジュール単位でDBアクセスを集約することで、ビジネスロジックとの分離が図れます（DAOパターン的な役割）。
入力: 各種SQL問い合わせ内容（またはパラメータ）
出力: DBクエリ結果（取得データ）や処理成否

入出力は上記のように各モジュール内で閉じています。モジュール間のやりとりは主にメソッド呼び出しとデータ受け渡しで行われます。例えば、Discordのメッセージを受信するとdiscord_clientからllm_clientの処理を呼び出し、場合によってはtodo_service等のメソッドを叩いてDB更新し、その結果をdiscord_client経由でユーザーに返す、というフローになります。

なお、実装にはdiscord.pyのCog機構を活用します。Cogとはdiscord.pyの提供するクラスベースのコマンド集約機能で、Botのコマンドやイベントをモジュールごと（クラス単位）にまとめられます ￼ ￼。例えば、ToDo管理用にTodoCogクラスを作成しcommands.Cogを継承させて、@commands.command()でadd_todoやlist_todosコマンドを定義する、といった形です。こうすることでコードの見通しが良くなり、後から新しいコマンドを追加する際も既存コードに最小限の変更で済みます ￼。本Botは単一ユーザー向けDM Botではありますが、今後機能が増えてコマンド数が増えても保守しやすい構造となるよう、最初からCogによるモジュール分割を行います。

4. 各スキルの簡易APIインターフェース（ToDo/Remind/Schedule）

各サービスモジュール（ToDo管理・リマインダー・予定管理）は、Bot内部で呼び出し可能なクラス or 関数のAPIインターフェースを持ちます。これにより、LLMからの関数呼び出しやDiscordコマンドから各機能を実行できます。以下に各スキルの簡易的なインターフェース例を示します（Pythonの疑似コード形式）。

# ToDo管理サービスのインターフェース例
class TodoService:
    def add_task(self, description: str, due_date: str = None) -> int:
        """新しいToDoタスクを追加し、そのタスクID（主キー）を返す"""
        # ...（SQLiteにINSERTし、lastrowidを返す）
        return task_id

    def list_tasks(self) -> List[Tuple[int, str, bool, str]]:
        """現在のToDoタスク一覧を取得する（(id, 内容, 完了フラグ, 期限)のリスト）"""
        # ...（SQLiteからSELECTしてタプルのリストを返す）
        return tasks

    def complete_task(self, task_id: int) -> bool:
        """指定IDのタスクを完了済みにマークする"""
        # ...（completedフラグを更新）
        return True

    def delete_task(self, task_id: int) -> bool:
        """指定IDのタスクを削除する"""
        # ...（DELETEクエリ実行）
        return True

上記のように、ToDoサービスではタスク追加・一覧取得・完了処理・削除のメソッドを提供します。それぞれ必要なパラメータを受け取り、内部でデータベースにアクセスして処理を行います。戻り値は処理結果として、追加時は新規タスクのID、一覧取得時はタスクの配列、完了・削除時は成功可否のbool等となります。

# リマインダーサービスのインターフェース例
class ReminderService:
    def add_reminder(self, message: str, remind_time: str) -> int:
        """新しいリマインダーを追加し、そのIDを返す"""
        # ...（SQLiteにINSERT）
        return reminder_id

    def list_reminders(self) -> List[Tuple[int, str, str, bool]]:
        """登録済みリマインダーの一覧を取得（(id, 内容, 時刻, 通知済フラグ)のリスト）"""
        # ...（SQLite SELECT）
        return reminders

    def cancel_reminder(self, reminder_id: int) -> bool:
        """指定IDのリマインダーをキャンセル（削除）する"""
        # ...（DELETE実行）
        return True

    async def start_scheduler(self):
        """（非同期処理）定期的に現在時刻をチェックし、通知すべきリマインダーがあればユーザーにDM送信"""
        # ...（discord.Clientのオブジェクト経由でDM送信）

リマインダーサービスでは追加・一覧・キャンセルに加え、時間になったら通知を送るためのスケジューラ処理を持ちます。ここではstart_schedulerという非同期メソッドで、例えばdiscord.ext.tasks.loopデコレータを用いて一定間隔（例: 1分ごと）に実行されるループを走らせます。現在時刻に達した未通知のリマインダーをDBから検索し、発見した場合はDiscordのDMでユーザーに通知し、当該リマインダーを通知済みに更新します。通知送信にはDiscordクライアントのインスタンスが必要なので、このクラスを初期化する際にBotクライアントへの参照を受け取る設計にするか、あるいはコールバックを登録する形にします（詳細は設計次第ですが、簡易実装ではReminderServiceにdiscord.Clientを渡しても良いでしょう）。

# スケジュール管理サービスのインターフェース例
class ScheduleService:
    def add_event(self, title: str, event_time: str) -> int:
        """新しい予定を追加し、そのイベントIDを返す"""
        # ...（INSERT）
        return event_id

    def list_events(self, start_time: str = None, end_time: str = None) -> List[Tuple[int, str, str]]:
        """予定一覧を取得（期間を指定可能。要指定なければ全件取得）"""
        # ...（SELECT。start_time～end_timeでフィルタリング）
        return events

    def delete_event(self, event_id: int) -> bool:
        """指定したイベントIDの予定を削除"""
        # ...（DELETE実行）
        return True

スケジュールサービスも基本的には追加・一覧・削除のインターフェースを提供します。今回は簡易な予定管理とのことなので、更新（編集）処理などは省略し、新規追加と削除のみ実装します。list_eventsでは引数で期間を受け取り、その範囲の予定を返すようにしています（使わない場合は全予定）。内部ではeventsテーブルを操作し、予定の日時でソートして返すと良いでしょう。

以上のように、各サービスクラスはメソッドを通じて機能をカプセル化しており、他の部分（LLM連携モジュールやDiscordイベント処理）からこれらメソッドを呼ぶことで実際の処理が行われます。例えば、「Buy milkをToDoに追加して」というユーザー発話に対し、LLMがadd_task関数の呼び出しを返してきた場合、TodoService.add_task("Buy milk", None)を実行し、その結果IDをLLMに渡して「追加しました」と回答させる、という流れになります。

5. LLMとの連携インターフェース（プロンプト構成・関数呼び出し）

本Botでは、OpenAIのChatGPT APIを通じて高度な自然言語処理を行い、ユーザーからの要求を解釈・応答します。その際、ChatGPTに対して適切なシステムプロンプトを与え、さらにOpenAI APIの関数呼び出し (Function Calling) 機能を活用してBot内の機能を呼び出すよう設計します。

プロンプト設計

ChatGPT APIへのリクエストはメッセージのリスト（会話履歴）で構成されます。本Botでは以下のような役割のメッセージを組み立てます：
	•	システムメッセージ: ボットの挙動や人格を規定する指示を記述します。例: 「あなたはJunのパーソナルアシスタントです。ユーザーの質問に日本語で答えてください。ToDo管理やリマインダー設定が可能です。」等。これにより、Botが回答時に敬語にするかどうか、簡潔に答えるかなどのスタイルも指定できます。必要に応じて、このシステムメッセージで利用可能な関数（後述）の説明を与え、どんな場合にそれらを使うか指示します。
	•	ユーザーメッセージ: Discordから転送されたユーザー(Jun)の発話内容です。これはそのままChatGPT APIのuserロールのメッセージとして送ります。例えば「明日の10時に会議のリマインドお願い」といった自然文のリクエストが入ります。
	•	（オプション）アシスタントメッセージ: 直前のChatGPTとのやりとり（コンテキスト）を保持したい場合に使用します。本BotはDM専用でユーザーも1人なので、簡易的には直近の1～2回のQAを保持して文脈を与える程度で良いでしょう。必要な場合のみ付加します。

以上をopenai.ChatCompletion.create()の引数messagesに設定します。また、関数呼び出しを使うためにfunctionsパラメータを構築します。

OpenAI関数呼び出しの活用

OpenAIのChatGPT（GPT-3.5/4）モデルは、あらかじめ関数の仕様を与えることで、ユーザーの指示に応じて適切な関数を自動選択し、引数を抽出して呼び出すためのJSONレスポンスを生成できます ￼。本Botではこの機能を用いて、ユーザーからの自然な依頼文から直接Bot内部の各サービス関数を呼び出します。

まず、OpenAI APIに渡すfunctions引数として、Botが提供する機能を定義します。具体的には前述のTodoService.add_taskやReminderService.add_reminder等に対応するメタ情報を与えます。例えば以下のようにPython側で設定します。

functions = [
    {
      "name": "add_task",
      "description": "Add a new todo task to the list",
      "parameters": {
          "type": "object",
          "properties": {
              "description": {"type": "string", "description": "The task description"},
              "due_date": {"type": "string", "description": "Optional due date (YYYY-MM-DD format)"}
          },
          "required": ["description"]
      }
    },
    {
      "name": "add_reminder",
      "description": "Set a reminder and notify the user at specified time",
      "parameters": {
          "type": "object",
          "properties": {
              "message": {"type": "string", "description": "Reminder message content"},
              "remind_time": {"type": "string", "description": "Reminder time in ISO format or natural language"}
          },
          "required": ["message", "remind_time"]
      }
    },
    ... （他の関数定義も同様に記述） ...
]
response = openai.ChatCompletion.create(
    model="gpt-4-0613",
    messages=messages,
    functions=functions,
    function_call="auto"   # 自動的に関数呼び出しを判断
)

上記のように関数名、説明、パラメータ（JSONスキーマ形式）を与えると、モデルはユーザーの入力を解析し、該当する操作があれば対応する関数を選択します。例えば「〇〇をToDoに追加して」という入力に対し、モデルはadd_task関数を選び、{"description": "〇〇", "due_date": null}のようなargumentsを生成します。GPT-3.5-TurboやGPT-4はユーザーの要求に応じて適切な関数を自動選択し、正規化された引数を返すことができます ￼ ￼。

OpenAI APIからのレスポンスは、通常のメッセージ（assistant role, contentあり）の場合と、関数コールを含む場合があります。レスポンスを解析する際、response.choices[0].message.function_callフィールドの有無をチェックします ￼ ￼。関数呼び出しがあった場合、例えば：

"function_call": {
   "name": "add_reminder",
   "arguments": "{ \"message\": \"会議に出席してください\", \"remind_time\": \"2025-07-11T10:00:00+09:00\" }"
}

のような情報が得られます。Python側でこのJSON文字列をパースし、対応するサービスクラスのメソッド（上記例ではReminderService.add_reminder("会議に出席してください", "2025-07-11T10:00:00+09:00")）を呼び出します ￼。関数の実行結果（戻り値）を取得したら、それを関数実行結果メッセージとして再度ChatGPTに渡し、最終的なユーザー向け応答を生成します ￼ ￼。例えば「リマインダーを登録しました。IDは3です。」といったメッセージを作らせ、それをDiscord経由でユーザーに送信します。

一方、ユーザーからの一般的な質問（例えば「パリの首都はどこ？」など、Botの内部機能と無関係なもの）の場合、モデルはどの関数も呼び出さず通常のテキスト回答を返します ￼。Function Callingでは、定義されていない関数にマッチしない場合や必要ない場合、自動的に通常のテキスト応答にフォールバックするため、QA機能とコマンド実行機能の両立がシンプルに行えます ￼。この性質により、本Botは1つのChatGPTインスタンスで汎用的な質問応答と個別機能の操作をシームレスに実現できます。

まとめると、LLM連携インターフェースでは：
	•	システムプロンプトでBotの役割と使用可能な機能を説明
	•	OpenAI APIの関数定義機能でBotの内部操作をエクスポーズ
	•	ユーザー入力に対し、モデルが自動でfunction call or 通常回答を選択
	•	function call時はPython側で実処理を行い、その結果をモデルに返して最終応答生成

というフローを取ります。この設計により、ユーザーはコマンドの厳密な構文を覚えずとも自然な言葉でBotに依頼でき、Botは柔軟に応答または処理を実行できます。

6. データベース設計（テーブル構造とスキーマ）

本BotではSQLiteデータベースを利用してToDo、リマインダー、予定を永続的に保存します。SQLiteはファイルベースの軽量DBで、サーバーを別途用意する必要がなく、自宅サーバー環境でも手軽に扱えます ￼ ￼。

データベース名は例えばjun_assistant.db（SQLiteファイル）とし、以下のようなテーブルを設けます。それぞれ単純なスキーマで、1レコードが1つのタスク/リマインド/予定を表します。
	•	tasks テーブル（ToDo管理用）
ユーザーのToDoタスクを格納します。構造は次の通りです：

カラム名	型	説明
id	INTEGER PRIMARY KEY AUTOINCREMENT	タスクID（主キー、自動採番）
description	TEXT NOT NULL	タスクの内容
due_date	TEXT	締切日時（任意。ISO8601文字列など）
completed	BOOLEAN NOT NULL DEFAULT 0	完了済みフラグ (0=未完了, 1=完了)
created_at	TEXT NOT NULL	作成日時（ISO8601文字列）

用途: 新規タスク追加時にINSERTし、一覧取得や完了フラグ更新、削除操作を行います。最小限の構造のため、カテゴリー分け等はしていません（必要ならcategoryカラムを追加検討）。

	•	reminders テーブル（リマインダー用）
ユーザーへのリマインダー設定を格納します。構造：

カラム名	型	説明
id	INTEGER PRIMARY KEY AUTOINCREMENT	リマインダーID（主キー）
message	TEXT NOT NULL	リマインドするメッセージ内容
remind_time	TEXT NOT NULL	リマインド予定日時（UTCまたはローカルのISO8601文字列）
reminded	BOOLEAN NOT NULL DEFAULT 0	通知済みフラグ (0=未通知, 1=通知済み)
created_at	TEXT NOT NULL	作成日時（ISO8601文字列）

用途: リマインダー追加時にINSERTし、定期チェックで現在時刻を過ぎた未通知レコードをSELECTします。通知送信後、そのレコードのremindedを1に更新します。過去のリマインダー履歴を残したくない場合は通知後DELETEする設計も考えられますが、再通知防止のためフラグ管理にしています。

	•	events テーブル（予定管理用）
ユーザーの予定（スケジュール）を格納します：

カラム名	型	説明
id	INTEGER PRIMARY KEY AUTOINCREMENT	イベントID（主キー）
title	TEXT NOT NULL	イベント（予定）のタイトル
event_time	TEXT NOT NULL	イベント日時（ISO8601文字列）
location	TEXT	場所や追加情報（任意）
created_at	TEXT NOT NULL	作成日時（ISO8601文字列）

用途: 予定を追加するとINSERTし、一覧表示では指定期間に該当するレコードをSELECTします。locationは簡易実装では使わないかもしれませんが、将来的な拡張も見据えてフィールドを用意しています（不要なら省略可能）。

各テーブルとも、単一ユーザー運用前提のためユーザーID等のフィールドは設けていません。Junさん専用Botなので、全レコードがJunさんに属するとみなせます（今後マルチユーザー対応する際は各テーブルにuser_idカラムを追加し、レコードを紐付ける必要があります）。

主キーは自動採番の整数IDで、一意にレコードを識別します。外部キーは今回の要件では特に無いため設定していません（例えばタスクと予定を関連付ける等が発生したらFKを検討）。

インデックスは主キーにデフォルトで付与されています。加えて、必要に応じ日時系カラムにインデックスを張ることも検討します（大量のデータを扱う場合）ですが、個人利用規模では不要でしょう。

テーブル作成はアプリ初回起動時にdata_store.py内で次のようなSQLを実行して行います（テーブルが存在しなければCREATEする処理）:

conn = sqlite3.connect('jun_assistant.db')
cursor = conn.cursor()
# tasksテーブル
cursor.execute("""
    CREATE TABLE IF NOT EXISTS tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        description TEXT NOT NULL,
        due_date TEXT,
        completed BOOLEAN NOT NULL DEFAULT 0,
        created_at TEXT NOT NULL
    )
""")
# remindersテーブル
cursor.execute("""
    CREATE TABLE IF NOT EXISTS reminders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        message TEXT NOT NULL,
        remind_time TEXT NOT NULL,
        reminded BOOLEAN NOT NULL DEFAULT 0,
        created_at TEXT NOT NULL
    )
""")
# eventsテーブル
cursor.execute("""
    CREATE TABLE IF NOT EXISTS events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        event_time TEXT NOT NULL,
        location TEXT,
        created_at TEXT NOT NULL
    )
""")
conn.commit()

上記のようにSQLスクリプトを直書きしても良いですが、コード量が増えるようなら別途SQLスクリプトファイルに切り出し、起動時に読み込んで実行する方法でも構いません。

データ型についてSQLiteは動的型付けですが、一貫性のためBOOLEANには0/1を、日時はISO8601文字列（TEXT）で保存しています（比較・ソートもしやすいため）。代わりにUNIXタイムスタンプ（INTEGER）で保持し、入出力時に変換する手もあります。実装の簡便さを優先し、ここでは文字列で扱っています。

7. 環境変数と設定ファイル（config.yaml と .env）

機密情報や環境依存の値をコードから分離し、外部ファイルで管理することは安全性・保守性の面で非常に重要です。本Botでは、環境変数ファイル .env と 設定ファイル config.yaml を用意し、用途に応じて使い分けます。

.envファイルと環境変数

.envファイルには、APIキーやトークンなど公開すべきではない情報を記述します ￼。例えば以下のようになります。

DISCORD_TOKEN=abcdefg...          # Discordボットのトークン
OPENAI_API_KEY=sk-xxxxxxxx...     # OpenAI APIキー

このファイルはpython-dotenvライブラリで読み込まれ、プログラム実行時に環境変数として登録されます ￼。実装としては、main.pyの先頭で:

from dotenv import load_dotenv
load_dotenv()  # .env をロード

import os
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

のように記述します。こうすることで、コード中に直接キー文字列を埋め込まずに済み、誤ってソースコードを公開してもキーが漏洩する危険が減ります。

セキュリティ注意: .envファイル自体はGitなどバージョン管理には登録しないようにします。プロジェクトの.gitignoreに.envを追加しておけば、誤ってコミットされることを防げます ￼。環境変数として切り出すべきものは、環境によって値が変わる項目や秘密情報全般です ￼。本Botでは前述のトークン類の他、（必要に応じて）データベースのパスなども環境変数化できます。

config.yaml設定ファイル

一方で、機密ではない動作設定やユーザーごとの調整値はconfig.yamlに記述します。YAML形式は直感的に読めて、階層的な設定を管理するのに適しています。例えば、本Bot用のconfig.yamlは次のようになります。

openai:
  model: gpt-4            # 使用するモデル (gpt-3.5-turbo も可)
  temperature: 0.7        # 応答のランダム性（任意調整値）

discord:
  allowed_user_id: 123456789012345678   # JunさんのDiscordユーザーID
  command_prefix: "!"    # Botのテキストコマンドプレフィックス（DMでは不要だが将来用）

reminder:
  check_interval: 60     # リマインダーのポーリング間隔（秒）

timezone: "Asia/Tokyo"   # デフォルトのタイムゾーン（日時表示や解析に使用）

config.yamlの項目例:
	•	OpenAIの使用モデルやパラメータ (温度等)
	•	Discord関連設定（特定ユーザー以外無視するためのIDや、コマンドプレフィックス）
	•	リマインダーのチェック間隔など機能固有の設定値
	•	タイムゾーンなど環境設定

プログラムでは、YAMLパーサ(PyYAML)でこれを読み込み、Pythonの辞書として扱います。例えばconfig = yaml.safe_load(open("config.yaml", "r"))のようにして取得し、config["openai"]["model"]のようにアクセスします ￼。DiscordBot起動時にallowed_user_idを読み込んでおけば、on_messageイベントで発言者のIDと比較して、自分以外からのDMには反応しないようにできます（シングルユーザー運用の保証）。

設定情報の分離メリット

これら環境変数・設定ファイルを分離することで、コードの再デプロイ無しに挙動を調整できます。たとえば、モデルをGPT-3.5からGPT-4に変更したい場合、config.yamlの該当箇所を編集してBotプロセスを再起動するだけで済みます。あるいは、Botトークンをローテーションする際も、コードには手を触れず.envを書き換えるだけで対応できます。

また、機密情報をリポジトリに含めないことで、うっかり公開リポジトリにプッシュしてしまった場合のリスクも軽減されます ￼。チーム開発では.envは各環境で別途用意し共有しないという運用になりますが、本Botは個人用なので管理もしやすいでしょう。

最後に、環境変数 vs 設定ファイルの使い分けについてまとめます。
	•	.env: 秘密情報（APIキー、トークン）、環境ごとに異なるパスやクレデンシャル。
	•	config.yaml: 動作モードや各種デフォルト値、ユーザー設定。

この棲み分けにより、コードは「設定」をハードコーディングせずに済み、保守性・可搬性が向上します。

8. 起動・常駐化方法（systemd, nohup）

自宅サーバー上でBotを常時稼働させるには、サーバー起動時にBotスクリプトを自動実行する仕組みが必要です。ここでは一般的なLinuxサービスマネージャであるsystemdを用いた方法と、簡易なnohupコマンドによる方法の両方について述べます。

systemdによる常駐化

systemdを使うと、BotをOSのサービスとして登録し、自動起動やコケたときの再起動を行えます ￼。まず、適切なサービスユニットファイルを作成します。例えば/etc/systemd/system/junbot.serviceとして以下のように記述します。

[Unit]
Description=Jun Personal AI Assistant Discord Bot
After=network.target

[Service]
Type=simple
WorkingDirectory=/home/jun/jun_personal_ai_bot   ; Botコードのディレクトリ
ExecStart=/usr/bin/python3 /home/jun/jun_personal_ai_bot/main.py
Restart=always
User=jun          ; 実行ユーザー。一般ユーザーを指定
Environment="PYTHONUNBUFFERED=1"  ; (任意) 出力をバッファしない
# EnvironmentFile=-/home/jun/jun_personal_ai_bot/.env  ; (任意) .envを読み込む方法

[Install]
WantedBy=multi-user.target

上記の設定では、ネットワークが利用可能になってから（After=network.target）Botサービスを開始し、main.pyを指定ユーザーで起動します。Restart=alwaysにより異常終了した場合も自動で再起動します ￼。EnvironmentFileはコメントアウトしていますが、systemd側で環境変数を読み込ませる方法です（python-dotenvでコード内読み込みしている場合は不要です）。

このユニットファイルを配置したら、以下のコマンドでサービスを有効化・起動します。

sudo systemctl daemon-reload            # ユニットファイルの読み込み
sudo systemctl enable junbot.service    # サーバー起動時に自動起動するよう設定
sudo systemctl start junbot.service     # 今すぐサービス起動

# ステータス確認やログ確認
sudo systemctl status junbot.service
sudo journalctl -u junbot.service -f

statusで現在の動作状況（稼働中／エラー）を確認でき、journalctl -fでログをリアルタイムで追えます ￼。これでサーバー再起動後もBotがバックグラウンドで常駐するようになります。

nohupやその他による起動

簡易な方法として、ターミナルから直接Botを起動しそのまま放置する方法もあります。例えばnohupコマンドを使えば、ログアウト後もプロセスが動き続けます。

cd /home/jun/jun_personal_ai_bot
nohup python3 main.py > bot.log 2>&1 &

このコマンドでBotをバックグラウンド実行し、出力をbot.logにリダイレクトしています。&を付けることでバックグラウンド実行、nohupで親シェルから切り離しているため、SSHセッションを閉じてもプロセスが残ります。簡便ですが、サーバ再起動時には自動起動しない点と、プロセス管理（再起動など）が手動になる点に注意が必要です。

他にもtmuxやscreenといったターミナル多重化ツール内でBotを動かし続ける方法もあります。開発中はこちらが手軽ですが、本番運用では前述のsystemdによる管理を推奨します。

Bot停止方法

systemd管理の場合：sudo systemctl stop junbot.serviceで停止し、再開はstart、再起動はrestartコマンドになります。nohup等の場合はプロセスIDを調べてkillするか、ログインし直したターミナルからフォアグラウンド実行していればCtrl+Cで停止できます。

起動時の注意

Discord Botでは起動時にDiscord Developer Portalで設定したトークンを使って認証します。トークンが間違っているとログにエラーが出て接続できません。また初回起動時にIntents周りの設定（特にDMメッセージ内容を取得するにはMessage Content Intentを有効にする必要）が正しくないと、DMの内容が取れない場合があります。intentsの設定はコードとDiscordアプリ側の両方で確認してください。

9. 保守性・拡張性に配慮した設計上の注意点

最後に、本Botの設計・実装において保守しやすさと拡張の容易さを確保するためのポイントをまとめます。
	•	モジュール分離と関心の分離: 前述の通り、機能ごとにコードを分割しました。一つのファイルにすべてを書かないことで、コード量が増えても見通しを保てます。例えばToDo機能に関する変更はtodo_service.py内で完結しやすく、他の機能へ影響しにくくなっています ￼。これはバグ修正や機能追加の際のリスク低減につながります。
	•	クラス・関数の役割の明確化: 各クラス/関数は一つの責務に専念させます（単一責任の原則）。Discordイベント処理はdiscord_clientモジュール、ビジネスロジックは各サービス、データ保存はdata_store、と分けることで、ある部分の変更が他に伝播しにくくなります。また、役割が明確になることでユニットテストもしやすくなります。
	•	設定値の外出しとドキュメント化: config.yamlに調整可能なパラメータを持たせましたが、これらはREADMEや本仕様書にきちんと説明を書いておきます。開発者（将来的に別の人かもしれません）が設定意図を理解できるようにし、パラメータ変更でどのような挙動変化があるか把握できる状態が望ましいです。
	•	環境変数管理: .envに機密情報を分離し、Git管理から除外しました ￼。これによりセキュリティを確保していますが、環境変数名や必要項目についてはREADME等に一覧し、デプロイ時のチェックリストを整備します。環境変数読み込みには失敗すると起動できないため、os.getenvで取得した後値を検証し、見つからなければ明示的なログやエラーを出すようにするとデバッグしやすくなります。
	•	ログとエラーハンドリング: 保守性の観点ではログ出力も重要です。どのようなユーザー要求が来て、LLMからどんなfunction_callが返ってきたか、データベース操作が成功したか、例外は起きなかったか――これらをログに記録することで、問題発生時に原因調査が容易になります。Pythonのloggingモジュールを使い、INFOレベルで各主要処理の開始終了、ERRORレベルで例外内容をログファイルに残すと良いでしょう。特にOpenAI APIはネットワークエラーやレート制限エラーがあり得るので、失敗時に再試行する処理とともにエラー内容を記録します。
	•	OpenAI API利用の工夫: コストと性能面で、GPT-4を使うかGPT-3.5を使うか選択肢があります。config.yamlでモデルを切り替えられるようにしたのはそのためです。また、関数呼び出し機能により自然言語コマンド解析を任せていますが、プロンプトの設計如何で精度が変わります。運用しながら「こういう言い方では誤解された」等あれば、システムプロンプトを調整してどのように応答してほしいかルールを追加していくことも必要でしょう。
	•	拡張のしやすさ: 新機能を追加する場合の手順を簡単にまとめます。例えば「天気情報を教えて」という機能を追加したい場合、(1) 新しいサービスモジュールweather_service.pyを作成し、天気API呼び出しロジックを実装。(2) ChatGPTのfunctions定義にget_weatherを追加。（必要ならシステムメッセージにも案内を追記）(3) DiscordのCogコマンドも追加（任意）。これだけで、ユーザーは「東京の天気教えて」とDMするだけでBotがweather_serviceを呼び出し、天気を回答する機能を拡張できます。つまり、本設計では機能追加時に既存コードへの変更が最小限で済みます。各サービスが独立しているため、副作用も少ないでしょう。
	•	単一ユーザー前提の簡略化: Junさん専用であるため省略した部分もあります。例えばユーザー認証やコマンド権限管理、多人数の同時利用に伴うデータ競合処理などです。将来的に利用者を増やす場合は、各所でユーザーIDを考慮する必要があります（テーブル構造、Botが反応する範囲、同時実行リクエストのキュー管理など）。拡張の際にはその点を念頭に置いてください。
	•	コードコメントとドキュメント: 保守性向上の基本として、コード中に適切なコメントや関数のdocstringを書いておきます。特に複雑な処理（例えばLLMの応答を解析して関数呼出に繋げる部分など）は、後から読む人が流れを追いやすいように説明を添えると良いでしょう。また、この仕様書自体を含めリポジトリ内に開発者向けドキュメントを置き、セットアップ手順やトラブルシューティングなどを記しておくと、時間が経ってからの自分自身や他の開発者への引き継ぎに役立ちます。

以上の点を踏まえて実装すれば、Junさん専用AIエージェントBotは堅牢で保守しやすく、拡張にも強い構成となります。モジュール分割とOpenAI APIの活用により、コード量の割に高機能なBotが実現できる見込みです。今後の要件追加にも柔軟に対応できるよう、設定可能な箇所は外出しし、シンプルな設計を維持することを念頭に置いて開発を進めてください。 ￼ ￼
